{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nexport default function useGamePadPress(fn) {\n  _s();\n\n  const [gamepads, setGamepads] = useState([]);\n\n  const hasGamepadAPI = () => \"getGamepads\" in navigator;\n\n  useEffect(() => {\n    let gamepadIndex;\n    window.addEventListener(\"gamepadconnected\", function (e) {\n      gamepadIndex = e.gamepad.index;\n      setGamepads(e);\n      setInterval(() => {\n        if (gamepadIndex !== undefined) {\n          // a gamepad is connected and has an index\n          const myGamepad = gamepads[gamepadIndex];\n\n          if (myGamepad) {\n            myGamepad.buttons.map(e => e.pressed).forEach((isPressed, buttonIndex) => {\n              if (isPressed) {\n                console.log(buttonIndex);\n              }\n            });\n          }\n        }\n      }, 100);\n    });\n    window.addEventListener(\"gamepaddisconnected\", function (e) {\n      console.log(e);\n    });\n  }, [fn]);\n}\n\n_s(useGamePadPress, \"NXRSuj1A7wfGse9ty4kBHuQqZuc=\");","map":{"version":3,"sources":["C:/Users/markm/OneDrive/Desktop/gamedeveloper/react-game/src/game-tools/utils/hooks/gamepad-press/useGamePadPress.js"],"names":["useEffect","useState","useGamePadPress","fn","gamepads","setGamepads","hasGamepadAPI","navigator","gamepadIndex","window","addEventListener","e","gamepad","index","setInterval","undefined","myGamepad","buttons","map","pressed","forEach","isPressed","buttonIndex","console","log"],"mappings":";;AAAA,SAAQA,SAAR,EAAmBC,QAAnB,QAAkC,OAAlC;AAGA,eAAe,SAASC,eAAT,CAAyBC,EAAzB,EAA6B;AAAA;;AACxC,QAAM,CAACC,QAAD,EAAWC,WAAX,IAA0BJ,QAAQ,CAAC,EAAD,CAAxC;;AACA,QAAMK,aAAa,GAAG,MAAM,iBAAiBC,SAA7C;;AAEAP,EAAAA,SAAS,CAAC,MAAK;AAEP,QAAIQ,YAAJ;AAEAC,IAAAA,MAAM,CAACC,gBAAP,CAAwB,kBAAxB,EAA4C,UAASC,CAAT,EAAY;AACpDH,MAAAA,YAAY,GAAGG,CAAC,CAACC,OAAF,CAAUC,KAAzB;AACAR,MAAAA,WAAW,CAACM,CAAD,CAAX;AACAG,MAAAA,WAAW,CAAC,MAAM;AACd,YAAGN,YAAY,KAAKO,SAApB,EAA+B;AAC3B;AACA,gBAAMC,SAAS,GAAGZ,QAAQ,CAACI,YAAD,CAA1B;;AACA,cAAGQ,SAAH,EAAa;AACTA,YAAAA,SAAS,CAACC,OAAV,CAAkBC,GAAlB,CAAsBP,CAAC,IAAIA,CAAC,CAACQ,OAA7B,EAAsCC,OAAtC,CAA8C,CAACC,SAAD,EAAYC,WAAZ,KAA4B;AACtE,kBAAGD,SAAH,EAAc;AACVE,gBAAAA,OAAO,CAACC,GAAR,CAAYF,WAAZ;AACH;AACJ,aAJD;AAKH;AACJ;AACJ,OAZU,EAYR,GAZQ,CAAX;AAaH,KAhBD;AAkBAb,IAAAA,MAAM,CAACC,gBAAP,CAAwB,qBAAxB,EAA+C,UAAUC,CAAV,EAAa;AACxDY,MAAAA,OAAO,CAACC,GAAR,CAAYb,CAAZ;AACH,KAFD;AAIH,GA1BI,EA2BH,CAACR,EAAD,CA3BG,CAAT;AA6BH;;GAjCuBD,e","sourcesContent":["import {useEffect, useState} from \"react\";\r\n\r\n\r\nexport default function useGamePadPress(fn) {\r\n    const [gamepads, setGamepads] = useState([]);\r\n    const hasGamepadAPI = () => \"getGamepads\" in navigator;\r\n\r\n    useEffect(() =>{\r\n\r\n            let gamepadIndex;\r\n\r\n            window.addEventListener(\"gamepadconnected\", function(e) {\r\n                gamepadIndex = e.gamepad.index;\r\n                setGamepads(e);\r\n                setInterval(() => {\r\n                    if(gamepadIndex !== undefined) {\r\n                        // a gamepad is connected and has an index\r\n                        const myGamepad = gamepads[gamepadIndex];\r\n                        if(myGamepad){\r\n                            myGamepad.buttons.map(e => e.pressed).forEach((isPressed, buttonIndex) => {\r\n                                if(isPressed) {\r\n                                    console.log(buttonIndex);\r\n                                }\r\n                            })\r\n                        }\r\n                    }\r\n                }, 100)\r\n            });\r\n\r\n            window.addEventListener(\"gamepaddisconnected\", function (e) {\r\n                console.log(e);\r\n            });\r\n\r\n        }\r\n        , [fn]);\r\n\r\n}"]},"metadata":{},"sourceType":"module"}